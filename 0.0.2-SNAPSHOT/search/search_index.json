{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Introduction","text":""},{"location":"#inspekt","title":"Inspekt","text":"<p>100% multiplatform, 100% compile time reflection for Kotlin. Includes:</p> <ul> <li>Inspecting classes, functions, and properties</li> <li>Top-level declaration support</li> <li>Annotation instances</li> <li>Function invocation, including <code>suspend</code> functions</li> <li><code>is</code> checking and casting</li> <li>JVM-like proxies</li> <li>Reflecting over dependencies</li> <li>Seamless reflection over Java classes</li> <li>GraalVM compatible out of the box (I think, it's not tested yet)</li> </ul>"},{"location":"#getting-started","title":"Getting started","text":"<p>To use Inspekt, just apply the Gradle plugin:</p> <pre><code>plugins {\n    id(\"dev.rnett.inspekt\") version \"&lt;version&gt;\" // see the Maven Central badge above\n}\n</code></pre> <p>and call <code>inspekt</code> from your code:</p> <pre><code>val fooClass = inspekt(Foo::class)\n\nfoo.function(\"bar\").invoke {\n    dispatchReceiver = Foo()\n}\n</code></pre> <p>Other Compiler Plugins</p> <p>Compatibility with other compiler plugins depends on the plugin and is not at all guaranteed or even expected to work. Use at your own risk. It will most likely work for declarations generated by other plugins if you use the compiler plugin ordering parameter to ensure Inspekt (which has id <code>dev.rnett.inspekt.compiler-plugin</code>) runs after the other plugin(s).</p> <p>It is 0% compatible with <code>@Compsoable</code> functions.</p>"},{"location":"#examples","title":"Examples","text":"<p>Some basic examples are located in the examples directory of the GitHub repo.</p>"},{"location":"binary-size/","title":"Binary Size","text":"<p>Unlike traditional reflection, which relies on metadata already present in your compiled code, Inspekt generates the necessary reflection information at compile-time. This is what makes Kotlin Multiplatform support possible, but it also means that the more you use <code>inspekt()</code>, the larger your binary becomes. This is true of all of Inspekt's intrinsic methods: <code>inspekt</code>, <code>proxy</code>, <code>proxyFactory</code>, etc.</p> <p>See How it works for details on the transformations done by the compiler plugin.</p>"},{"location":"binary-size/#what-contributes-to-binary-size","title":"What Contributes to Binary Size?","text":"<p>Each call site of <code>inspekt()</code> function causes the compiler plugin to generate new code and metadata for the inspected declaration. This includes:</p> <ul> <li>Member Metadata: Information about properties, functions, parameters, and annotations.</li> <li>Invokers: Specialized code that allows Inspekt to call your functions and get/set properties efficiently.</li> <li>Type Information: Details about type parameters, generic types, and class hierarchies.</li> </ul> <p>Call sites vs calls</p> <p>The size added by <code>inspekt()</code>, <code>proxy()</code>, and other intrinsics, is determined by the number of call sites compiled, i.e. the number of <code>inspekt()</code>s in your code. How many times that call is executed has no effect - <code>inspekt(Foo::class)</code> adds the same amount of binary size as <code>repeat(1000) { inspekt(Foo::class) }</code>.</p> <p>The total impact on your binary size is determined by two main factors:</p> <ol> <li>Number of <code>inspekt()</code> calls: Each call site of <code>inspekt()</code> is essentially a new \"instance\" of reflection metadata in your compiled code.</li> <li>Complexity of the inspected declaration: A large class with many members will result in more generated metadata than a small class or a single function.</li> </ol>"},{"location":"binary-size/#managing-binary-size","title":"Managing Binary Size","text":"<p>Here are several strategies for keeping your binary size under control:</p>"},{"location":"binary-size/#reuse-inspektion-objects","title":"Reuse Inspektion Objects","text":"<p>The most effective way to minimize binary size is to have as few <code>inspekt()</code> call sites as possible. If you need to inspect the same class in multiple places, store the <code>Inspektion</code> object in a property or a singleton and reuse it.</p> <pre><code>// Good: Call once and reuse\nobject MyReflection {\n    val fooInspektion = inspekt(Foo::class)\n}\n\n// Bad: Each call adds to the binary\nfun doSomething() {\n    val foo = inspekt(Foo::class)\n}\n</code></pre> <p>Because the call itself is replaced by the compiler plugin, using a helper method will also work fine:</p> <pre><code>fun getFooInspektion() = inspekt(Foo::class)\n</code></pre> <p>But you would still needlessly re-create the object each time.</p>"},{"location":"binary-size/#proxies","title":"Proxies","text":"<p>Like <code>inspekt()</code>, each call site of <code>proxy()</code> adds to the binary size. Unlike <code>inspekt()</code>, you can't really store the result of calling <code>proxy()</code>, because it depends on the handler.</p> <p>To avoid adding binary size, wrap repeated proxy calls for the same interface in a helper function:</p> <pre><code>fun createFooProxy(handler: ProxyHandler) = proxy(Foo::class, handler)\n</code></pre> <p>Or just use <code>proxyFactory</code>, which does that for you.</p>"},{"location":"how-it-works/","title":"How It Works","text":"<p>Inspekt is powered by a Kotlin compiler plugin that replaces <code>inspekt</code> and <code>proxy</code> calls with their results. It works by generating the necessary metadata and code at compile-time, allowing you to use it on any Kotlin platform, including Kotlin/JS and Kotlin/Native. This also makes it compatible with GraalVM, proguard, etc, without any additional configuration.</p>"},{"location":"how-it-works/#the-compiler-plugin","title":"The Compiler Plugin","text":"<p>The core of Inspekt is a Kotlin compiler plugin. When the plugin is applied to your project, replaces any calls to <code>inspekt()</code>, <code>proxy()</code>, and the other intrinsic functions.</p>"},{"location":"how-it-works/#inspekt","title":"<code>inspekt</code>","text":"<p><code>inspekt()</code> calls are replaced by the constructor for the returned type, e.g. <code>Inspektion</code> or <code>SimpleFunction</code>. The target is inspected, and its metadata, and that of any child declarations, is used to fill in the object's constructor arguments (for example, with the declaration's fully qualified name, or function parameters). For functions, invoker lambdas are generated that call the function with arguments extracted from the passed <code>ArgumentsList</code>.</p> <p>For example, a call like this:</p> <pre><code>class Foo(val bar: Int) {\n    fun baz(): String = bar.toString()\n}\n\nval test = inspekt(Foo::class)\n</code></pre> <p>will be turned into something like this:</p> <pre><code>class Foo(val bar: Int) {\n    fun baz(): String = bar.toString()\n}\n\nval test = Inspektion(\n    kotlin = Foo::class,\n    name = \"Foo\",\n    superTypes = listOf(typeOf&lt;Any&gt;()),\n    annotations = emptyList(),\n    objectInstance = null,\n    constructors = listOf(\n        Constructor(\n            isPrimary = true,\n            parameters = listOf(Parameter(name = \"bar\", type = typeOf&lt;Int&gt;(), index = 0)),\n            invoker = { args -&gt;\n                Foo(args[0] as Int)\n            }\n        )\n    ),\n    properties = listOf(),\n    functions = listOf(\n        Function(\n            name = \"baz\",\n            returnType = typeOf&lt;String&gt;(),\n            parameters = listOf(Parameter(name = \"this\", kind = Kind.DISPATCH, type = typeOf&lt;Foo&gt;(), index = 0)),\n            invoker = { args -&gt;\n                (args[0] as Foo).baz()\n            }\n        )\n    )\n)\n</code></pre>"},{"location":"how-it-works/#proxy","title":"<code>proxy</code>","text":"<p><code>proxy()</code> calls are replaced by an anonymous object that implements the target interface. Every method in the interface is overridden by an implementation that assembles its arguments into an <code>ArgumentsList</code> and calls the proxy handler, returning the result. Inspektions are also generated for all of the interface's members and used to populate the <code>SuperCall</code> object passed to the handler.</p> <p><code>proxyFactory()</code> and <code>inspektAndProxy</code> are very similar, they just wrap the anonymous object creation in a lambda that takes the handler instance.</p> <p>For example, a call like:</p> <pre><code>interface Foo {\n    fun bar(a: Int): Int = a + 2\n    fun baz(): String\n}\n\nval test = proxy(Foo::class) {\n    if (functionName == \"bar\") {\n        return callSuper()\n    } else if (functionName == \"baz\") {\n        return \"test\"\n    }\n    error(\"Unrecognized function $functionName!\")\n}\n</code></pre> <p>will be turned into something like this:</p> <pre><code>interface Foo {\n    fun bar(a: Int): Int = a + 2\n    fun baz(): String\n}\n\nval test = object : Foo {\n    private val handler: ProxyHandler = {\n        if (functionName == \"bar\") {\n            return callSuper()\n        } else if (functionName == \"baz\") {\n            return \"test\"\n        }\n        error(\"Unrecognized function $functionName!\")\n    }\n\n    private val barInspektion = inspekt(Foo::bar)\n\n    override fun bar(a: Int): Int {\n        val args = ArgumentList(this, a)\n        return with(handler) { SuperCall(barInspektion, args).handle() }\n    }\n\n    private val bazInspektion = inspekt(Foo::baz)\n    override fun baz(): String {\n        val args = ArgumentList(this)\n        return with(handler) { SuperCall(bazInspektion, args).handle() }\n    }\n}\n</code></pre>"},{"location":"inspektion/","title":"Inspektion","text":"<p>The primary entry point for using Inspekt is the <code>inspekt()</code> function. It provides access to a comprehensive model of your code at runtime, without the overhead or restrictions of JVM reflection.</p>"},{"location":"inspektion/#creating-an-inspektion","title":"Creating an Inspektion","text":"<p>To inspect a class, call <code>inspekt</code> with a class reference literal:</p> <pre><code>val fooInspektion = inspekt(Foo::class)\n</code></pre> <p>You can also inspect individual functions or properties:</p> <pre><code>val barFunction = inspekt(Foo::bar)\nval bazProperty = inspekt(Foo::baz)\n</code></pre> <p>Calling <code>inspekt</code> on method references with receivers, e.g. <code>inspekt(foo::bar)</code> is the same as calling it on just <code>Foo::bar</code> - only the function or property referenced is relevant.</p>"},{"location":"inspektion/#constraints","title":"Constraints","text":"<p>The <code>inspekt()</code> function is a compiler intrinsic. This means it has several constraints:</p> <ul> <li>Literals only: You must pass a class, function, or property reference literal (e.g., <code>Foo::class</code>, <code>Foo::bar</code>). You cannot pass a variable containing a <code>KClass</code> or <code>KFunction</code>, even if it's a constant.</li> <li>Visibility: You can only inspect declarations that are visible at the call site, and the inspektion will only contain members that are visible at the call site.</li> <li>Compile-time: The <code>Inspektion</code> object is constructed at compile-time. Each call to <code>inspekt()</code> generates a new instance in the compiled code. See Binary Size.</li> </ul>"},{"location":"inspektion/#the-data-model","title":"The Data Model","text":"<p>An <code>Inspektion&lt;T&gt;</code> provides a detailed view of the class <code>T</code>, including:</p> <ul> <li>Properties: All properties, including those inherited from superclasses.</li> <li>Functions: All functions, including those inherited.</li> <li>Constructors: All available constructors.</li> <li>Type Parameters: Generic type information.</li> <li>Annotations: Access to annotations on the class and its members. Instances of the annotations are provided.</li> <li>Hierarchy: Supertypes and sealed subclasses.</li> </ul> <p>All visible members of the class will be included, including those inherited by supertypes (e.g. a default <code>equals</code> implementation). To determine where members were declared, use the <code>isDeclared</code> and <code>inheritedFrom</code> properties.</p>"},{"location":"inspektion/#finding-members","title":"Finding Members","text":"<p>You can look up members by name or iterate through the lists:</p> <pre><code>val prop = fooInspektion.property(\"myProperty\")\nval func = fooInspektion.function(\"myFunction\")\n\nval allPublicFunctions = fooInspektion.functions.filter { /* ... */ }\n</code></pre>"},{"location":"inspektion/#working-with-objects","title":"Working with Objects","text":"<p>If the inspected class is a Kotlin <code>object</code>, you can access its instance directly:</p> <pre><code>val instance = inspekt(MyObject::class).objectInstance\n</code></pre> <p>Similarly, you can access the <code>companionObject</code> if one exists.</p>"},{"location":"inspektion/#casting-and-instance-checks","title":"Casting and Instance Checks","text":"<p><code>Inspektion</code> provides multiplatform-safe alternatives to <code>as</code>, <code>as?</code>, and <code>is</code>:</p> <pre><code>if (fooInspektion.isInstance(someValue)) {\n    val casted = fooInspektion.cast(someValue)\n}\n\nval safe = fooInspektion.safeCast(anotherValue)\n</code></pre> <p>These are particularly useful when you have an <code>Inspektion&lt;*&gt;</code> and need to perform type-safe operations in common code.</p>"},{"location":"inspektion/#invoking-methods","title":"Invoking methods","text":"<p>Inspekted functions can be invoked, and properties gotten and set. See Invoking Methods for details.</p> <p>The class <code>Inspektion</code> object provides some utilities for invoking member functions, such as <code>callFunction</code>, <code>getProperty</code>, and <code>setProperty</code>, which are also available as the <code>invoke</code>, <code>get</code>, and <code>set</code> operators, respectively. These methods only work when there is a single function or property for a given name - if that's not the case, you can still find the member using <code>functions</code> or <code>properties</code> and invoke it using its own invocation methods.</p>"},{"location":"inspektion/#best-practices","title":"Best Practices","text":"<ul> <li>Reuse Inspektion objects: Since each <code>inspekt()</code> call adds to your binary size, it is best to call it once and store the result in a property or variable if you need to use it multiple times.</li> <li>Prefer member-specific inspekt: If you only need a single function or property, use <code>inspekt(Foo::bar)</code> instead of <code>inspekt(Foo::class).function(\"bar\")</code> to minimize the amount of generated metadata.</li> </ul>"},{"location":"invoking/","title":"Invoking Functions","text":"<p>Inspekt allows invoking functions that have been inspekted, including property accessors.</p> <p>Of course, this only works if the function has a body that can be invoked. If you are inspekting a concrete class, this is guaranteed. But if the inspektion is of an abstract class, such as the interface for a proxy, some members may not be invokable. To check this, check the <code>isInvokable</code> property. Functions with <code>reified</code> type parameters are also not invokable, so it is important to use <code>isInvokable</code> instead of <code>isAbstract</code>. You may also want to check <code>isSuspend</code> - attempting to invoke a suspending function using the <code>invoke</code> method (instead of <code>invokeSuspend</code>) will throw an error.</p> <p><code>Inspektion</code> also provides convenient shorthand utilities for invoking and accessing non-ambiguous member functions and properties, see Inspektion.</p>"},{"location":"invoking/#the-invoke-function","title":"The Invoke function","text":"<p>The most common way to call a function is using the <code>invoke</code> method. It uses a lambda block to configure the arguments.</p> <pre><code>val foo = Foo()\nval result = inspekt(Foo::bar).invoke {\n    dispatchReceiver = foo\n    value(arg1, arg2)\n}\n</code></pre>"},{"location":"invoking/#arguments","title":"Arguments","text":"<p>All arguments are stored in a flat list matching the parameter order. The ordering of argument and parameter kinds matches that used by the Kotlin compiler:</p> <ul> <li>Dispatch receiver (if present)</li> <li>Context parameters</li> <li>Extension receiver (if present)</li> <li>Value parameters</li> </ul> <p>The <code>invoke</code> lambda's receiver, <code>ArgumentList.Builder</code>, provides many utilities for setting arguments:</p> <ul> <li><code>dispatchReceiver</code></li> <li><code>extensionReceiver</code></li> <li><code>this[Kind, index] = value</code></li> <li><code>context(context1, context2, ...)</code></li> <li><code>value(value1, value2, ...)</code></li> <li>And more \u2013 see the API documentation.</li> </ul> <p>To use the default value of an argument, do not set it. Setting an argument to <code>null</code> actually passes <code>null</code> and will not use the default.</p> <p>Some limited type checking is done for arguments before calling the method, but it is limited to what is available at runtime using <code>KType</code>.</p>"},{"location":"invoking/#suspend-functions","title":"Suspend Functions","text":"<p>Invoking <code>suspend</code> functions is just as easy, but you must use the <code>invokeSuspend</code> method within a coroutine or another <code>suspend</code> function:</p> <pre><code>suspend fun example() {\n    val result = inspekt(Foo::asyncTask).invokeSuspend {\n        dispatchReceiver = Foo()\n        value(\"some data\")\n    }\n}\n</code></pre> <p>Calling <code>invoke</code> on a <code>suspend</code> function will throw an exception. Calling <code>invokeSuspend</code> on a non-suspend function will work fine, and just call the non-suspending invoker.</p>"},{"location":"invoking/#properties","title":"Properties","text":"<p>You can also get and set property values using a similar syntax:</p> <pre><code>val value = prop.get { dispatchReceiver = foo }\nprop.set {\n    dispatchReceiver = foo\n    value(newValue)\n}\n</code></pre> <p>or by using <code>invoke</code> on their getter or setter:</p> <pre><code>prop.getter.invoke { dispatchReceiver = foo }\n</code></pre>"},{"location":"proxies/","title":"Proxies","text":"<p>Inspekt allows you to create proxies for interfaces at runtime. This provides a similar mechanism to <code>java.lang.reflect.Proxy</code> on the JVM, but is completely multiplatform and created at compile-time.</p>"},{"location":"proxies/#creating-a-proxy","title":"Creating a Proxy","text":"<p>To create a proxy for an interface, use the <code>proxy()</code> function and provide a <code>ProxyHandler</code>:</p> <pre><code>val myProxy = proxy(MyInterface::class) {\n    // handler implementation\n}\n</code></pre>"},{"location":"proxies/#the-proxy-handler","title":"The Proxy Handler","text":"<p>A <code>ProxyHandler</code> is a functional interface that receives all calls to the proxy's methods. Your implementation of <code>handle()</code> decides how to respond to the call.</p> <pre><code>val handler = ProxyHandler {\n    // This block is called for every function call on the proxy\n    println(\"Calling ${functionName} with arguments: $args\")\n\n    // Return the result of the call\n    \"Return value\"\n}\n</code></pre> <p>The handler is called with the <code>SuperCall</code> receiver, which gives it access to both the argument of the call, and the inspektion of the original called method. Some properties of note:</p> <ul> <li><code>functionName: String</code> and <code>propertyName: String?</code> - the short names of the function, and the property if the function is an accessor</li> <li><code>args: ArgumentList</code> - the arguments passed to the call, with convenient accessors for different parameters</li> <li><code>isSuperCallable: Boolean</code> - whether the super function can be called</li> <li><code>isSuspending: Boolean</code> - whether the call and function are suspending</li> <li><code>callSuper()</code>/<code>callSuperSuspend()</code> - call the original implementation of the function with the same arguments, or with an arguments builder</li> </ul>"},{"location":"proxies/#suspend-support","title":"Suspend Support","text":"<p>If the interface has <code>suspend</code> functions, you can implement <code>handleSuspend()</code>:</p> <pre><code>val handler = object : ProxyHandler {\n    override fun handle(): Any? { /* ... */\n    }\n\n    override suspend fun handleSuspend(): Any? {\n        // Handle suspend calls here\n        return someAsyncOperation()\n    }\n}\n</code></pre> <p>If not implemented, calling suspend methods will use <code>handle</code>.</p>"}]}